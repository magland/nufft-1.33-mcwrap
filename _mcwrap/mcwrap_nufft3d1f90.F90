!
!
! This file was auto-generated by MCWRAP
! https://github.com/magland/mcwrap
!
! You should not edit this file.
! You might not even want to read it.
! 
! 

#include "fintrf.h"

!====================================================================
!====================================================================

!     Gateway routine
subroutine mexFunction(nlhs, plhs, nrhs, prhs)

!     Declarations
      implicit none
      integer ii,jj
      mwSize numdims
      integer*4 dims(100)
      integer*4, ALLOCATABLE :: dims2(:)
      character*120 debug_line

!     mexFunction arguments:
      mwPointer plhs(*), prhs(*)
      integer nlhs, nrhs

!     Function declarations:
      mwPointer mxGetPr, mxGetPi
      mwPointer mxCreateNumericArray
      integer*4 mxClassIDFromClassName
      integer mxIsNumeric
      mwSize mxGetNumberOfDimensions
      mwPointer mxGetDimensions
      integer mcwrap_size

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     Declare inputs:
        !xj
        mwPointer p_input_xj
        real*8, ALLOCATABLE :: input_xj(:)
        !yj
        mwPointer p_input_yj
        real*8, ALLOCATABLE :: input_yj(:)
        !zj
        mwPointer p_input_zj
        real*8, ALLOCATABLE :: input_zj(:)
        !cj
        mwPointer p_input_cj_re
        mwPointer p_input_cj_im
        real*8, ALLOCATABLE :: input_cj(:)
        real*8, ALLOCATABLE :: input_cj_re(:)
        real*8, ALLOCATABLE :: input_cj_im(:)
        !iflag
        mwPointer p_input_iflag
        Integer input_iflag
        real*8 input_iflag_double
        !eps
        mwPointer p_input_eps
        real*8 input_eps
        !ms
        mwPointer p_input_ms
        Integer input_ms
        real*8 input_ms_double
        !mt
        mwPointer p_input_mt
        Integer input_mt
        real*8 input_mt_double
        !mu
        mwPointer p_input_mu
        Integer input_mu
        real*8 input_mu_double

!     Declare outputs:
        !fk
        mwPointer p_output_fk_re
        mwPointer p_output_fk_im
        real*8, ALLOCATABLE :: output_fk(:)
        real*8, ALLOCATABLE :: output_fk_re(:)
        real*8, ALLOCATABLE :: output_fk_im(:)
        !ier
        mwPointer p_output_ier
        integer, ALLOCATABLE :: output_ier(:)
        real*8, ALLOCATABLE :: output_ier_double(:)

!     Declare set inputs:
        !nj
        integer input_nj

      !call mexPrintf('test A'//char(10))
!-----Check the number of inputs/outputs
      if (nlhs==0) then
          nlhs=1
      end if
      if(nrhs .ne. 9) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Incorrect number of inputs') 
      elseif(nlhs .gt. 2) then
         call mexErrMsgIdAndTxt ('MCWRAP:IO','Too many outputs.')
      endif


      !call mexPrintf('test A.2'//char(10))
!-----Setup the set inputs
        !nj
        input_nj=int(mcwrap_size(prhs(1),1))

    
      !call mexPrintf('test B'//char(10))
!-----Setup the inputs
        !xj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(1))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: xj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(1)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: xj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): xj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_xj=mxGetPr(prhs(1));
        ALLOCATE(input_xj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_xj,input_xj,int((input_nj)*(1)))
        
        !yj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(2))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: yj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(2)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: yj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): yj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_yj=mxGetPr(prhs(2));
        ALLOCATE(input_yj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_yj,input_yj,int((input_nj)*(1)))
        
        !zj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(3))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: zj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(3)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: zj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): zj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_zj=mxGetPr(prhs(3));
        ALLOCATE(input_zj((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_zj,input_zj,int((input_nj)*(1)))
        
        !cj
        !Check that we have the correct dimensions!
        numdims=mxGetNumberOfDimensions(prhs(4))
        if (numdims .gt. 2) then
          call mexErrMsgTxt('Incorrect number of dimensions in input: cj')
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(prhs(4)),dims,numdims)
        ALLOCATE(dims2(2))
        dims2=(/ input_nj,1 /)
        do ii=1,2
          if (ii .le. numdims) then
              if (dims(ii) .ne. dims2(ii)) then
                call mexErrMsgTxt('Incorrect size of input: cj')
              end if
          else
            if (dims2(ii) .ne. 1) then
              call mexErrMsgTxt('Incorrect size of input (*): cj')
            end if
          end if;
        end do
        DEALLOCATE(dims2)
        p_input_cj_re=mxGetPr(prhs(4));
        p_input_cj_im=mxGetPi(prhs(4));
        ALLOCATE(input_cj((input_nj)*(1)*2))
        ALLOCATE(input_cj_re((input_nj)*(1)))
        ALLOCATE(input_cj_im((input_nj)*(1)))
        call mxCopyPtrToReal8(p_input_cj_re,input_cj_re,int((input_nj)*(1)))
        if (p_input_cj_im .NE. 0) then
            call mxCopyPtrToReal8(p_input_cj_im,input_cj_im,int((input_nj)*(1)))
        end if
        do ii=1,(input_nj)*(1)
            input_cj(1+(ii-1)*2)=input_cj_re(ii)
            if (p_input_cj_im .NE. 0) then
            input_cj(1+(ii-1)*2+1)=input_cj_im(ii)
            else
            input_cj(1+(ii-1)*2+1)=0    
            end if
        end do
        !iflag
        p_input_iflag=mxGetPr(prhs(5));
        call mxCopyPtrToReal8(p_input_iflag,input_iflag_double,1)
        input_iflag=int(input_iflag_double)
        !eps
        p_input_eps=mxGetPr(prhs(6));
        call mxCopyPtrToReal8(p_input_eps,input_eps,1)
        !ms
        p_input_ms=mxGetPr(prhs(7));
        call mxCopyPtrToReal8(p_input_ms,input_ms_double,1)
        input_ms=int(input_ms_double)
        !mt
        p_input_mt=mxGetPr(prhs(8));
        call mxCopyPtrToReal8(p_input_mt,input_mt_double,1)
        input_mt=int(input_mt_double)
        !mu
        p_input_mu=mxGetPr(prhs(9));
        call mxCopyPtrToReal8(p_input_mu,input_mu_double,1)
        input_mu=int(input_mu_double)
    
      !call mexPrintf('test C'//char(10))
!-----Setup the outputs
        !fk
        if (1 .LE. nlhs) then
        if ((3 .lt. 1) .or. (3 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 3') 
        end if
        ALLOCATE(dims2(3))
        dims2=(/ input_ms,input_mt,input_mu /)
        do ii=1,3
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: input_ms,input_mt,input_mu') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(1)=mxCreateNumericArray(3,(/ input_ms,input_mt,input_mu /),mxClassIDFromClassName('double'),1)
            p_output_fk_re=mxGetPr(plhs(1))
            p_output_fk_im=mxGetPi(plhs(1))
        end if
        ALLOCATE(output_fk(int((input_ms)*(input_mt)*(input_mu))*2))
        ALLOCATE(output_fk_re(int((input_ms)*(input_mt)*(input_mu))))
        ALLOCATE(output_fk_im(int((input_ms)*(input_mt)*(input_mu))))
        !ier
        if (2 .LE. nlhs) then
        if ((2 .lt. 1) .or. (2 .gt. 20)) then
          call mexErrMsgTxt ('Bad number of dimensions for my taste: 2') 
        end if
        ALLOCATE(dims2(2))
        dims2=(/ 1,1 /)
        do ii=1,2
            if ((dims2(ii) .lt. 1) .or. (dims2(ii) .gt. 10000000000.0)) then
              call mexErrMsgTxt ('Bad array size for my taste: 1,1') 
            end if
        end do
        DEALLOCATE(dims2)
        
            plhs(2)=mxCreateNumericArray(2,(/ 1,1 /),mxClassIDFromClassName('double'),0)
            p_output_ier=mxGetPr(plhs(2))
        end if
        ALLOCATE(output_ier(int((1)*(1))))
        ALLOCATE(output_ier_double(int((1)*(1))))

    
      !call mexPrintf('test D'//char(10))
!-----Run the subroutine
        call nufft3d1f90( &
        input_nj, &
        input_xj, &
        input_yj, &
        input_zj, &
        input_cj, &
        input_iflag, &
        input_eps, &
        input_ms, &
        input_mt, &
        input_mu, &
        output_fk, &
        output_ier &

        );
   
      !call mexPrintf('test E'//char(10))
!-----Free the inputs
        !xj
        DEALLOCATE(input_xj)
        !yj
        DEALLOCATE(input_yj)
        !zj
        DEALLOCATE(input_zj)
        !cj
        DEALLOCATE(input_cj)
        DEALLOCATE(input_cj_re)
        DEALLOCATE(input_cj_im)

      !call mexPrintf('test F'//char(10))
!-----Set the outputs
        !fk
        if (1 .LE. nlhs) then
            do ii=1,(input_ms)*(input_mt)*(input_mu)
                output_fk_re(ii)=output_fk(1+(ii-1)*2)
                output_fk_im(ii)=output_fk(1+(ii-1)*2+1)
            end do
            call mxCopyReal8ToPtr(output_fk_re,p_output_fk_re,int((input_ms)*(input_mt)*(input_mu)))
            call mxCopyReal8ToPtr(output_fk_im,p_output_fk_im,int((input_ms)*(input_mt)*(input_mu)))
        end if
        DEALLOCATE(output_fk)
        DEALLOCATE(output_fk_re)
        DEALLOCATE(output_fk_im)
        !ier
        if (2 .LE. nlhs) then
            do ii=1,(1)*(1)
                output_ier_double(ii)=output_ier(ii)
            end do
            call mxCopyReal8ToPtr(output_ier_double,p_output_ier,int((1)*(1)))
        end if
        DEALLOCATE(output_ier)
        DEALLOCATE(output_ier_double)

      !call mexPrintf('test G'//char(10))

!----- We are done -----!

        return
        end

    function mcwrap_size(X,j) result(ret)
        implicit none !important!!
        mwPointer X
        integer j
        integer*4 ret
        mwSize numdims
        integer*4 dims(100)
        mwSize mxGetNumberOfDimensions
        mwPointer mxGetDimensions
        
        numdims=mxGetNumberOfDimensions(X)
        if ((j .lt. 1) .or. (j .gt. numdims)) then
            ret=1
            return
        end if
        call mxCopyPtrToInteger4(mxGetDimensions(X),dims,numdims)
        ret=dims(j)
    end function mcwrap_size
